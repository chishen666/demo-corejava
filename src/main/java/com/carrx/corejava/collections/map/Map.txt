    Java中常用的Map实现类主要有：HashMap、HashTable、TreeMap、LinkedHashMap。
    
一.HashMap
1：新建HashMap，其实是新建了一个数组

2:插入元素
    1).HashMap不是简单的用key的hashcode()值作为元素的存放下标的，而是通过二次哈希——把key的hashcode()传进HashMap自定义的hash(h)方法中计算位置（有可能大于数组长度了，所以还要对数组长取余），
            然后通过indexFor(h，len)方法计算出具体的数组下标（用 按位与 取代 取余 加快效率），尽量让key尽可能均匀的分配到数组上去，避免造成Hash堆积（某一下标处存放的链表过长）。

    2).HashMap的冲突解决：如果有两个key的hashcode相同，那么经过hash(h)二次哈希后得到的数组索引是一样的，
                此时就要判断这两个key是否是同一对象：如果两个key的equals方法返回true，则说明两个key是同一对象，则此时把新值覆盖掉旧值；
                如果equals返回false，则说明是两个不同的key但分配到了同一数组索引位存放，则此时把新增的value添加到该索引位的链表尾。
                
3:读取元素
            在插入元素时我们看到，不同对象也有可能会有相同的哈希值，所以存放的时候数组索引是一样的。
            所以，我们通过key去获取value时不能只靠数组索引，还需在数组索引找到对应链表头的基础上，从头到尾遍历链表，把链表每个元素(Entry)的key与所查询的key通过equals方法进行比对，找到相等的结点来获取值。
            也就是说：插入元素时，通过key的hashcode()以及hash算法决定索引，通过equals()决定是插入链表还是覆盖原有值；
                  读取元素时，通过key的hashcode()以及hash算法找到索引，通过equals()遍历链表找到相对应的结点值；
                  （注：Map存储的是 键值对 ，不是单指用 key 来索引 value。而是用key 来索引 Entry！Entry就是我们说的 键值对！因此，get()时确定槽位后，在遍历Entry链表时才可以把查找的key与链表结点的key进行比较。）
                  
4:数组扩容
            我们在前面插入元素时就看到，当HashMap底层所用的数组使用量大于等于  数组最大容量*负载因子  时，就会触发数组扩容
            
5：HashMap线程不安全
    HashMap线程不安全的原因从上面的代码可以看出端倪——冲突的解决以及数组扩容  在多线程下容易发生竞态条件（结果取决于执行的顺序）。
            
            冲突造成不安全：当多个线程共同操作一个HashMap对象时，某一时刻都向map的key拥有相同的hashcode，
            若key是相同的对象，则最终的value值取决于哪个线程是最终执行的，覆盖掉前面的值；
            如果key是不同的对象，我们知道此时把值插入链表，而链表当前结点只有一个next指针，那么多个线程中都已缓存了这个指针，都认为这个指针是可用的，并令它指向了当前插入的新结点。
            那么最后同步回主内存时就会出问题了：指针只有一个。不能同时指向多个结点。

            扩容造成的不安全：当多个线程共同操作一个HashMap对象时，某一时刻同时触发了数组扩容，那么线程轮换执行时都对这个数组进行扩容会覆盖掉前面线程的扩容结果。
            
 二：HashTable
    HashTable底层也是一个“链表数组”，其插入元素和查询元素的策略与HashMap几乎一样。
            不同的是：很多线程敏感的方法用syncrhoized关键字进行修饰。所以，我们说：HashTable是线程安全的。（类似于Vector对ArrayList线程敏感的方法进行限定）
            
三：TreeMap
            与前面的两个map实现类不同，TreeMap是通过红黑树来实现的。所以针对TreeMap的插入元素、查找元素、删除元素等都是对红黑树的操作。
            
1：插入元素
            红黑树插入结点分两步：一是插入到排序二叉树的合适位置，二是对二叉树进行平衡（左右旋、重新着色）
            
2：删除元素
    TreeMap删除元素，就是在红黑树中删除一个结点。红黑树删除结点D：取D右分支最左边，或者 左分支最右边的子结点取代D，然后把子节点删除，之后再对红黑树进行平衡。
            
四：LinkedHashMap
    HashMap对键值对的组织是无顺序的。遍历顺序不一定是按照插入顺序，所以如果想按照插入顺序来遍历结果的话用HashMap是不行的。为此，我们可以使用LinkedHashMap。
            与LinkedHashSet类似，LinkedHashMap也是维护了一个双向链表，记录元素的插入顺序，然后再根据元素值，采用hashcode()、equals()方法来存储元素值并实现元素的唯一性。
            双向链表将所有put到LinkedHashmap的节点一一串成了一个双向循环链表，因此它保留了节点插入的顺序，可以使节点的输出顺序与输入顺序相同。