面向对象三大基本特征:封装,继承,多态
----------------------------------------------------------
封装:
a.把属性做成私有的private
b.给属性提供存/取值方法,一般命名为getter/setter方法

注:
构造方法是用来给属性赋值,而set方法也是给属性赋值的
它是构造方法的互补,因为构造方法只有一次机会,而set方法
有多次,有需要才调用.
set方法可以做属性值的有效判断
所以说,这也是我们把属性设置成私有的一个原因.

属性做成私有,一是为了保护封装性,二是为了set方法可做属性值有效判断.


封装的两种策略
实体类(entity):主要的目的就是存储数据
			   侧重点在于存储数据

业务类(service):主要的目的就是通过其中的业务方操作存储在实体类中的数据,
                侧重点在于功能.


策略一:
实体类和业务类合二为一(不推荐使用)

如:
//银行账户类
public class Account{
	//属性
	private long id;
	private String password;
	private String name;
	private double balance;

	//构造
	public Account(){...}
	...
	getter/setter
	...

	//业务方法
	public void deposit(double money) {
		if(money < 0){
			System.out.println("存入金额不能为负数!");
			return;
		}
		this.balance += money;
	}
	public void withdraw(double money) {
		if(money > balabce){
			System.out.println("余额不足");
			return;
		}
		this.balance -= money;
	}
}

策略二:
把实体类和业务类分开(推荐)

注意:业务类的命名规范为:实体类名+Service/Server/Biz

//实体类
public class Account{...}

//业务类
public class AccountService{
	// 存款
	public double deposit(Account acc,double money) {
		acc.setBalance(acc.getBalance() + money);
		return acc.getBalance();
	}

	// 取款
	public double withdraw(Account acc,double money) {
		acc.setBalance(acc.getBalance() - money);
		return acc.getBalance();
	}
}

//测试类
//创建实体类对象
Account acc = new Account(...);

//创建业务类对象
AccountService as = new AccountService();

//通过业务类调用业务方法
as.xxx();
----------------------------------------------------------
继承(Inheritance):

Java是一种单继承的开发语言,但是可以通过其他方法实现多继承(之后再说)

注意:
单继承表示最多只能有一个直接的父类,但是可以有多个间接的父类(线性结构)
多继承表示可以同时直接继承多个父类(网状结构)

JAVA中如何实现继承
关键字:extends

如:
class Super{}
class Sub extends Super{}

类Sub继承于Super,那么
Sub是子类,也叫派生类
Super是父类,也叫超类

问题:类Super的父类又是谁呢? ---> java.lang.Object,Java顶级父类

在java中,如果一个类没有继承于其他类,那么它就会自动继承Object类.

注:继承具有传递性
A继承于B,B继承于C,则A就会间接继承于C

Java中不支持多继承(但可以通过接口来实现)[C++支持多继承]
所以说Java中,单继承可以保证类的层次性,而不会产生网状结构
-----------------------------------------------------------------

一个类继承于另一个类,则子类可以访问父类中的所有非私有成员,
成员包含属性和方法.
-----------------------------------------------------------------
子类创建对象的过程
首先,按照如下3步,递归地创建父类对象
1.申请空间
2.初始化
3.调用构造方法
-----------------------------------------------------------------
super关键字
作用一:
在子类构造方法中,可以通过super关键字显式地调用父类的指定
带参数的构造器,如果是调用父类空参构造,则super()可以省略
注:super语句必须放在构造方法的第一句

作用二:
如果在子类中有与父类同名的属性,则子类中会把父类的属性给
掩盖了(shadow),所以,可以通过super关键字来访问父类的属性
语法:
super.属性名/super.方法名;

注:前提是这个父类的属性/方法不是private的
---------------------------------------------------------
使用继承的条件?

基本条件:两个类要满足"IS A"的关系,否则就不应该使用继承
如:
cat is animal
apple is fruit

所以,不要光为了复用代码而胡乱使用继承,这是不可取的

注:
尽可能的把各个子类中的共性抽象出来,放到父类中去

==> 面向父类编程,父类保留共性,子类保留个性.

---------------------------------------------------------

方法的重写(Override)
前提条件:
发生在父子类中,也就是只有有了继承,才有方法的重写

方法重写的条件:
1.方法名要相同
2.参数列表必须相同(类型,个数,顺序)
3.返回类型必须一致
4.修饰符访问权限必须等于或者小于父类中的方法修饰符
5.抛出的异常必须是父类相同的异常或者是其子类
---------------------------------------------------------
为什么我们要重写父类的方法?

编译时类型:指向对象引用的类型

运行时类型:指对象本身的真正类型

如:
Animal a = new Dog();
a是引用,它编译时的类型是:Animal
而它运行时对象是Dog,也就是说,它运行时是Dog类型

父类类型可以作为子类对象的编译时类型
这样,Object类型可以作为任意对象的编译时类型
但是
一个对象,只能使用这个对象编译时类型所含有的属性和方法
所以,如果你使用Object作为编译时类型的话,则只能使用Object
类中的方法或者属性.

所以,为了能够访问到对象的方法,我们应该在父类中提供这个
方法,并且在子类中重写该方法,这样,使用父类作为编译时类型
的时候,就可以调用这个方法,并且程序在运行时,真正去调用
子类对象的重写方法,这就是多态的特征.
---------------------------------------------------------
多态(Polymorphic)

条件:
1.一定要有继承
2.方法重写(静态方法可以重写,但是没有多态)

instanceof运算符
用法:
	对象 instanceof 类型;

如果对象的类型与运算符后面的类型一致,则返回true,
否则,返回false.

注:
后面的类型只要是对象的父类或者运行时类型都返回true

在做强制类型转换前,都要先做instanceof的类型判断
以保证不会出现java.lang.ClasCastException异常
